// Windows 95 Ê°åÈù¢Ê®°ÊãüÂô® JavaScript

class Windows95Desktop {
    constructor() {
        this.windows = [];
        this.windowZIndex = 100;
        this.activeWindow = null;
        this.startMenuOpen = false;
        this.soundEnabled = true;
        
        this.init();
    }

    init() {
        this.setupEventListeners();
        this.updateClock();
        this.playStartupSound();
        
        // ÊØèÁßíÊõ¥Êñ∞Êó∂Èíü
        setInterval(() => this.updateClock(), 1000);
    }

    setupEventListeners() {
        // ÂºÄÂßãÊåâÈíÆ
        document.getElementById('start-button').addEventListener('click', (e) => {
            e.stopPropagation();
            this.toggleStartMenu();
        });

        // Ê°åÈù¢ÁÇπÂáª
        document.getElementById('desktop').addEventListener('click', (e) => {
            if (e.target.id === 'desktop') {
                this.closeStartMenu();
                this.deselectAllIcons();
            }
        });

        // Ê°åÈù¢Âè≥ÈîÆËèúÂçï
        document.getElementById('desktop').addEventListener('contextmenu', (e) => {
            e.preventDefault();
            this.showContextMenu(e.clientX, e.clientY);
        });

        // ÂÖ≥Èó≠Âè≥ÈîÆËèúÂçï
        document.addEventListener('click', () => {
            this.hideContextMenu();
        });

        // Ê°åÈù¢ÂõæÊ†áÂèåÂáª
        document.querySelectorAll('.desktop-icon').forEach(icon => {
            icon.addEventListener('dblclick', () => {
                const app = icon.getAttribute('data-app');
                this.openApplication(app);
            });
            
            icon.addEventListener('click', (e) => {
                e.stopPropagation();
                this.selectIcon(icon);
            });
        });

        // ÂºÄÂßãËèúÂçïÈ°πÁÇπÂáª
        document.querySelectorAll('[data-app]').forEach(item => {
            item.addEventListener('click', () => {
                const app = item.getAttribute('data-app');
                this.openApplication(app);
                this.closeStartMenu();
            });
        });

        // ÂÖ≥Êú∫ÊåâÈíÆ
        document.getElementById('shutdown').addEventListener('click', () => {
            this.showShutdownDialog();
        });

        // ÂÖ®Â±ÄÈîÆÁõò‰∫ã‰ª∂
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'Escape') {
                // Ctrl+Esc ÊâìÂºÄÂºÄÂßãËèúÂçï
                this.toggleStartMenu();
            }
        });
    }

    // Èü≥ÊïàÁ≥ªÁªü
    playSound(soundId) {
        if (!this.soundEnabled) return;
        
        const audio = document.getElementById(soundId);
        if (audio) {
            audio.currentTime = 0;
            audio.play().catch(() => {
                // ÂøΩÁï•Êí≠ÊîæÂ§±Ë¥•
            });
        }
    }

    playStartupSound() {
        this.playSound('startup-sound');
    }

    playClickSound() {
        this.playSound('click-sound');
    }

    playErrorSound() {
        this.playSound('error-sound');
    }

    // Êó∂ÈíüÊõ¥Êñ∞
    updateClock() {
        const now = new Date();
        const timeString = now.toLocaleTimeString('zh-CN', {
            hour12: false,
            hour: '2-digit',
            minute: '2-digit'
        });
        document.getElementById('clock').textContent = timeString;
    }

    // ÂºÄÂßãËèúÂçïÁÆ°ÁêÜ
    toggleStartMenu() {
        this.playClickSound();
        const startMenu = document.getElementById('start-menu');
        const startButton = document.getElementById('start-button');
        
        this.startMenuOpen = !this.startMenuOpen;
        
        if (this.startMenuOpen) {
            startMenu.classList.remove('hidden');
            startButton.classList.add('active');
        } else {
            startMenu.classList.add('hidden');
            startButton.classList.remove('active');
        }
    }

    closeStartMenu() {
        if (this.startMenuOpen) {
            document.getElementById('start-menu').classList.add('hidden');
            document.getElementById('start-button').classList.remove('active');
            this.startMenuOpen = false;
        }
    }

    // Âè≥ÈîÆËèúÂçïÁÆ°ÁêÜ
    showContextMenu(x, y) {
        const contextMenu = document.getElementById('context-menu');
        contextMenu.style.left = x + 'px';
        contextMenu.style.top = y + 'px';
        contextMenu.classList.remove('hidden');
    }

    hideContextMenu() {
        document.getElementById('context-menu').classList.add('hidden');
    }

    // Ê°åÈù¢ÂõæÊ†áÁÆ°ÁêÜ
    selectIcon(icon) {
        this.deselectAllIcons();
        icon.classList.add('selected');
    }

    deselectAllIcons() {
        document.querySelectorAll('.desktop-icon').forEach(icon => {
            icon.classList.remove('selected');
        });
    }

    // Â∫îÁî®Á®ãÂ∫èÁÆ°ÁêÜ
    openApplication(appName) {
        this.playClickSound();
        
        switch (appName) {
            case 'notepad':
                this.openNotepad();
                break;
            case 'calculator':
                this.openCalculator();
                break;
            case 'paint':
                this.openPaint();
                break;
            case 'my-computer':
                this.openMyComputer();
                break;
            case 'recycle-bin':
                this.openRecycleBin();
                break;
            case 'minesweeper':
                this.openMinesweeper();
                break;
            default:
                this.showNotImplementedDialog(appName);
        }
    }

    // Á™óÂè£ÁÆ°ÁêÜ
    createWindow(title, content, width = 400, height = 300, icon = 'üìÑ') {
        const windowId = 'window-' + Date.now();
        const window = document.createElement('div');
        window.className = 'window active';
        window.id = windowId;
        window.style.width = width + 'px';
        window.style.height = height + 'px';
        window.style.left = (50 + this.windows.length * 30) + 'px';
        window.style.top = (50 + this.windows.length * 30) + 'px';
        window.style.zIndex = ++this.windowZIndex;

        window.innerHTML = `
            <div class="window-titlebar">
                <span class="window-title">${icon} ${title}</span>
                <div class="window-controls">
                    <div class="window-control" data-action="minimize">_</div>
                    <div class="window-control" data-action="maximize">‚ñ°</div>
                    <div class="window-control" data-action="close">√ó</div>
                </div>
            </div>
            <div class="window-content">
                ${content}
            </div>
        `;

        document.getElementById('windows-container').appendChild(window);
        
        this.setupWindowEvents(window, title, icon);
        this.addTaskbarButton(windowId, title, icon);
        
        this.windows.push({
            id: windowId,
            element: window,
            title: title,
            icon: icon,
            minimized: false,
            maximized: false
        });

        this.setActiveWindow(window);
        return window;
    }

    setupWindowEvents(window, title, icon) {
        const titlebar = window.querySelector('.window-titlebar');
        const controls = window.querySelectorAll('.window-control');
        
        // Á™óÂè£ÊãñÊãΩ
        let isDragging = false;
        let dragOffset = { x: 0, y: 0 };
        
        titlebar.addEventListener('mousedown', (e) => {
            if (e.target.classList.contains('window-control')) return;
            
            isDragging = true;
            this.setActiveWindow(window);
            
            const rect = window.getBoundingClientRect();
            dragOffset.x = e.clientX - rect.left;
            dragOffset.y = e.clientY - rect.top;
            
            document.addEventListener('mousemove', handleDrag);
            document.addEventListener('mouseup', stopDrag);
        });
        
        const handleDrag = (e) => {
            if (!isDragging || window.classList.contains('maximized')) return;
            
            window.style.left = (e.clientX - dragOffset.x) + 'px';
            window.style.top = (e.clientY - dragOffset.y) + 'px';
        };
        
        const stopDrag = () => {
            isDragging = false;
            document.removeEventListener('mousemove', handleDrag);
            document.removeEventListener('mouseup', stopDrag);
        };

        // Á™óÂè£ÊéßÂà∂ÊåâÈíÆ
        controls.forEach(control => {
            control.addEventListener('click', (e) => {
                e.stopPropagation();
                const action = control.getAttribute('data-action');
                
                switch (action) {
                    case 'minimize':
                        this.minimizeWindow(window);
                        break;
                    case 'maximize':
                        this.toggleMaximizeWindow(window);
                        break;
                    case 'close':
                        this.closeWindow(window);
                        break;
                }
            });
        });

        // Á™óÂè£ÁÇπÂáªÊøÄÊ¥ª
        window.addEventListener('mousedown', () => {
            this.setActiveWindow(window);
        });
    }

    setActiveWindow(window) {
        // ÁßªÈô§ÊâÄÊúâÁ™óÂè£ÁöÑÊ¥ªÂä®Áä∂ÊÄÅ
        document.querySelectorAll('.window').forEach(w => {
            w.classList.remove('active');
            w.classList.add('inactive');
        });
        
        // ËÆæÁΩÆÂΩìÂâçÁ™óÂè£‰∏∫Ê¥ªÂä®
        window.classList.add('active');
        window.classList.remove('inactive');
        window.style.zIndex = ++this.windowZIndex;
        
        this.activeWindow = window;
        
        // Êõ¥Êñ∞‰ªªÂä°Ê†èÊåâÈíÆÁä∂ÊÄÅ
        this.updateTaskbarButtons();
    }

    minimizeWindow(window) {
        window.style.display = 'none';
        const windowData = this.windows.find(w => w.element === window);
        if (windowData) {
            windowData.minimized = true;
        }
        this.updateTaskbarButtons();
    }

    toggleMaximizeWindow(window) {
        const windowData = this.windows.find(w => w.element === window);
        if (!windowData) return;
        
        if (windowData.maximized) {
            // ËøòÂéüÁ™óÂè£
            window.classList.remove('maximized');
            windowData.maximized = false;
        } else {
            // ÊúÄÂ§ßÂåñÁ™óÂè£
            window.classList.add('maximized');
            windowData.maximized = true;
        }
    }

    closeWindow(window) {
        const windowData = this.windows.find(w => w.element === window);
        if (!windowData) return;
        
        // ÁßªÈô§Á™óÂè£
        window.remove();
        
        // ÁßªÈô§‰ªªÂä°Ê†èÊåâÈíÆ
        this.removeTaskbarButton(windowData.id);
        
        // ‰ªéÁ™óÂè£ÂàóË°®‰∏≠ÁßªÈô§
        this.windows = this.windows.filter(w => w.id !== windowData.id);
        
        // Â¶ÇÊûúËøôÊòØÊ¥ªÂä®Á™óÂè£ÔºåÊøÄÊ¥ªÂè¶‰∏Ä‰∏™Á™óÂè£
        if (this.activeWindow === window) {
            const remainingWindows = document.querySelectorAll('.window');
            if (remainingWindows.length > 0) {
                this.setActiveWindow(remainingWindows[remainingWindows.length - 1]);
            } else {
                this.activeWindow = null;
            }
        }
    }

    // ‰ªªÂä°Ê†èÊåâÈíÆÁÆ°ÁêÜ
    addTaskbarButton(windowId, title, icon) {
        const button = document.createElement('div');
        button.className = 'taskbar-button active';
        button.id = 'taskbar-' + windowId;
        button.innerHTML = `
            <span class="button-icon">${icon}</span>
            <span class="button-text">${title}</span>
        `;
        
        button.addEventListener('click', () => {
            const window = document.getElementById(windowId);
            const windowData = this.windows.find(w => w.id === windowId);
            
            if (windowData && windowData.minimized) {
                // Â¶ÇÊûúÁ™óÂè£Ë¢´ÊúÄÂ∞èÂåñÔºåÊÅ¢Â§çÂÆÉ
                window.style.display = 'flex';
                windowData.minimized = false;
                this.setActiveWindow(window);
            } else if (this.activeWindow === window) {
                // Â¶ÇÊûúÊòØÊ¥ªÂä®Á™óÂè£ÔºåÊúÄÂ∞èÂåñÂÆÉ
                this.minimizeWindow(window);
            } else {
                // ÊøÄÊ¥ªÁ™óÂè£
                this.setActiveWindow(window);
            }
        });
        
        document.getElementById('taskbar-buttons').appendChild(button);
    }

    removeTaskbarButton(windowId) {
        const button = document.getElementById('taskbar-' + windowId);
        if (button) {
            button.remove();
        }
    }

    updateTaskbarButtons() {
        document.querySelectorAll('.taskbar-button').forEach(button => {
            button.classList.remove('active');
        });
        
        if (this.activeWindow) {
            const windowData = this.windows.find(w => w.element === this.activeWindow);
            if (windowData && !windowData.minimized) {
                const button = document.getElementById('taskbar-' + windowData.id);
                if (button) {
                    button.classList.add('active');
                }
            }
        }
    }

    // Â∫îÁî®Á®ãÂ∫èÂÆûÁé∞

    openNotepad() {
        const content = `
            <div class="notepad-content">
                <div class="notepad-menu">
                    <span class="notepad-menu-item">Êñá‰ª∂</span>
                    <span class="notepad-menu-item">ÁºñËæë</span>
                    <span class="notepad-menu-item">ÊêúÁ¥¢</span>
                    <span class="notepad-menu-item">Â∏ÆÂä©</span>
                </div>
                <textarea class="notepad-textarea" placeholder="Âú®Ê≠§ËæìÂÖ•ÊñáÊú¨..."></textarea>
            </div>
        `;
        
        this.createWindow('ËÆ∞‰∫ãÊú¨', content, 500, 400, 'üìù');
    }

    openCalculator() {
        const content = `
            <div class="calculator-content">
                <input type="text" class="calculator-display" value="0" readonly>
                <div class="calculator-buttons">
                    <button class="calculator-button" data-action="clear">C</button>
                    <button class="calculator-button" data-action="clear-entry">CE</button>
                    <button class="calculator-button" data-action="backspace">‚Üê</button>
                    <button class="calculator-button" data-action="divide">√∑</button>
                    <button class="calculator-button" data-number="7">7</button>
                    <button class="calculator-button" data-number="8">8</button>
                    <button class="calculator-button" data-number="9">9</button>
                    <button class="calculator-button" data-action="multiply">√ó</button>
                    <button class="calculator-button" data-number="4">4</button>
                    <button class="calculator-button" data-number="5">5</button>
                    <button class="calculator-button" data-number="6">6</button>
                    <button class="calculator-button" data-action="subtract">-</button>
                    <button class="calculator-button" data-number="1">1</button>
                    <button class="calculator-button" data-number="2">2</button>
                    <button class="calculator-button" data-number="3">3</button>
                    <button class="calculator-button" data-action="add">+</button>
                    <button class="calculator-button" data-number="0" style="grid-column: span 2;">0</button>
                    <button class="calculator-button" data-action="decimal">.</button>
                    <button class="calculator-button" data-action="equals">=</button>
                </div>
            </div>
        `;
        
        const window = this.createWindow('ËÆ°ÁÆóÂô®', content, 200, 260, 'üßÆ');
        this.setupCalculator(window);
    }

    setupCalculator(window) {
        const display = window.querySelector('.calculator-display');
        const buttons = window.querySelectorAll('.calculator-button');
        
        let currentValue = '0';
        let previousValue = null;
        let operation = null;
        let waitingForNewNumber = false;
        
        const updateDisplay = () => {
            display.value = currentValue;
        };
        
        const inputNumber = (num) => {
            if (waitingForNewNumber) {
                currentValue = num;
                waitingForNewNumber = false;
            } else {
                currentValue = currentValue === '0' ? num : currentValue + num;
            }
            updateDisplay();
        };
        
        const inputOperation = (nextOperation) => {
            const inputValue = parseFloat(currentValue);
            
            if (previousValue === null) {
                previousValue = inputValue;
            } else if (operation) {
                const result = calculate();
                currentValue = String(result);
                previousValue = result;
                updateDisplay();
            }
            
            waitingForNewNumber = true;
            operation = nextOperation;
        };
        
        const calculate = () => {
            const prev = previousValue;
            const current = parseFloat(currentValue);
            
            switch (operation) {
                case 'add': return prev + current;
                case 'subtract': return prev - current;
                case 'multiply': return prev * current;
                case 'divide': return current !== 0 ? prev / current : 0;
                default: return current;
            }
        };
        
        const performCalculation = () => {
            if (operation && previousValue !== null) {
                const result = calculate();
                currentValue = String(result);
                previousValue = null;
                operation = null;
                waitingForNewNumber = true;
                updateDisplay();
            }
        };
        
        buttons.forEach(button => {
            button.addEventListener('click', () => {
                const number = button.getAttribute('data-number');
                const action = button.getAttribute('data-action');
                
                if (number) {
                    inputNumber(number);
                } else if (action) {
                    switch (action) {
                        case 'clear':
                            currentValue = '0';
                            previousValue = null;
                            operation = null;
                            waitingForNewNumber = false;
                            updateDisplay();
                            break;
                        case 'clear-entry':
                            currentValue = '0';
                            updateDisplay();
                            break;
                        case 'backspace':
                            if (currentValue.length > 1) {
                                currentValue = currentValue.slice(0, -1);
                            } else {
                                currentValue = '0';
                            }
                            updateDisplay();
                            break;
                        case 'decimal':
                            if (currentValue.indexOf('.') === -1) {
                                currentValue += '.';
                                updateDisplay();
                            }
                            break;
                        case 'equals':
                            performCalculation();
                            break;
                        default:
                            inputOperation(action);
                    }
                }
            });
        });
    }

    openPaint() {
        const content = `
            <div class="paint-content">
                <div class="paint-toolbar">
                    <div class="paint-tool active" data-tool="brush">üñåÔ∏è</div>
                    <div class="paint-tool" data-tool="pencil">‚úèÔ∏è</div>
                    <div class="paint-tool" data-tool="eraser">üßΩ</div>
                    <div class="paint-tool" data-tool="fill">ü™£</div>
                    <div class="paint-tool" data-tool="text">üìù</div>
                    <div class="paint-tool" data-tool="line">üìè</div>
                    <div class="paint-tool" data-tool="rectangle">‚¨ú</div>
                    <div class="paint-tool" data-tool="circle">‚≠ï</div>
                </div>
                <div class="paint-canvas">
                    <canvas width="600" height="400" style="background: white; cursor: crosshair;"></canvas>
                </div>
            </div>
        `;
        
        const window = this.createWindow('ÁîªÂõæ', content, 640, 480, 'üé®');
        this.setupPaint(window);
    }

    setupPaint(window) {
        const canvas = window.querySelector('canvas');
        const ctx = canvas.getContext('2d');
        const tools = window.querySelectorAll('.paint-tool');
        
        let currentTool = 'brush';
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        
        // Â∑•ÂÖ∑ÈÄâÊã©
        tools.forEach(tool => {
            tool.addEventListener('click', () => {
                tools.forEach(t => t.classList.remove('active'));
                tool.classList.add('active');
                currentTool = tool.getAttribute('data-tool');
                
                // Êõ¥Êñ∞Èº†Ê†áÊ†∑Âºè
                switch (currentTool) {
                    case 'eraser':
                        canvas.style.cursor = 'grab';
                        break;
                    case 'text':
                        canvas.style.cursor = 'text';
                        break;
                    default:
                        canvas.style.cursor = 'crosshair';
                }
            });
        });
        
        // ÁªòÂõæ‰∫ã‰ª∂
        canvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            const rect = canvas.getBoundingClientRect();
            lastX = e.clientX - rect.left;
            lastY = e.clientY - rect.top;
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (!isDrawing) return;
            
            const rect = canvas.getBoundingClientRect();
            const currentX = e.clientX - rect.left;
            const currentY = e.clientY - rect.top;
            
            ctx.lineWidth = currentTool === 'eraser' ? 10 : 2;
            ctx.lineCap = 'round';
            
            if (currentTool === 'eraser') {
                ctx.globalCompositeOperation = 'destination-out';
            } else {
                ctx.globalCompositeOperation = 'source-over';
                ctx.strokeStyle = '#000';
            }
            
            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(currentX, currentY);
            ctx.stroke();
            
            lastX = currentX;
            lastY = currentY;
        });
        
        canvas.addEventListener('mouseup', () => {
            isDrawing = false;
        });
        
        canvas.addEventListener('mouseout', () => {
            isDrawing = false;
        });
    }

    openMyComputer() {
        const content = `
            <div style="display: flex; height: 100%;">
                <div style="width: 200px; border-right: 1px solid var(--win95-button-shadow); padding: 8px;">
                    <div style="margin-bottom: 8px; font-weight: bold;">ÊàëÁöÑÁîµËÑë</div>
                    <div style="margin-left: 16px;">
                        <div style="margin: 4px 0;">üíæ ËΩØÁõò (A:)</div>
                        <div style="margin: 4px 0;">üíø ÂÖâÈ©± (D:)</div>
                        <div style="margin: 4px 0;">üíæ Á°¨Áõò (C:)</div>
                        <div style="margin: 4px 0;">üåê ÁΩëÁªúÈÇªÂ±Ö</div>
                        <div style="margin: 4px 0;">üóëÔ∏è ÂõûÊî∂Á´ô</div>
                    </div>
                </div>
                <div style="flex: 1; padding: 8px;">
                    <div style="display: grid; grid-template-columns: repeat(auto-fill, 80px); gap: 16px;">
                        <div style="text-align: center;">
                            <div style="font-size: 32px;">üíæ</div>
                            <div style="font-size: 11px;">ËΩØÁõò (A:)</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 32px;">üíø</div>
                            <div style="font-size: 11px;">ÂÖâÈ©± (D:)</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 32px;">üíæ</div>
                            <div style="font-size: 11px;">Á°¨Áõò (C:)</div>
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        this.createWindow('ÊàëÁöÑÁîµËÑë', content, 600, 400, 'üíª');
    }

    openRecycleBin() {
        const content = `
            <div style="text-align: center; padding: 40px;">
                <div style="font-size: 64px; margin-bottom: 20px;">üóëÔ∏è</div>
                <div style="font-size: 14px; margin-bottom: 10px;">ÂõûÊî∂Á´ôÊòØÁ©∫ÁöÑ</div>
                <div style="font-size: 11px; color: var(--win95-dark-gray);">
                    Ë¶ÅÂà†Èô§È°πÁõÆÔºåËØ∑Â∞ÜÂÖ∂ÊãñÂà∞ÂõûÊî∂Á´ô‰∏≠„ÄÇ
                </div>
            </div>
        `;
        
        this.createWindow('ÂõûÊî∂Á´ô', content, 400, 300, 'üóëÔ∏è');
    }

    openMinesweeper() {
        const content = `
            <div style="padding: 16px; text-align: center;">
                <div style="margin-bottom: 16px; display: flex; justify-content: space-between; align-items: center;">
                    <div style="background: var(--win95-black); color: var(--win95-white); padding: 4px 8px; font-family: monospace;">üí£ 010</div>
                    <div style="font-size: 24px; cursor: pointer;">üòä</div>
                    <div style="background: var(--win95-black); color: var(--win95-white); padding: 4px 8px; font-family: monospace;">‚è±Ô∏è 000</div>
                </div>
                <div id="minesweeper-grid" style="display: grid; grid-template-columns: repeat(9, 20px); gap: 1px; justify-content: center; background: var(--win95-button-shadow);">
                    <!-- Êâ´Èõ∑ÁΩëÊ†ºÂ∞ÜÁî±JavaScriptÁîüÊàê -->
                </div>
                <div style="margin-top: 16px; font-size: 11px; color: var(--win95-dark-gray);">
                    Â∑¶ÈîÆÂçïÂáªÊâìÂºÄÊñπÂùóÔºåÂè≥ÈîÆÂçïÂáªÊ†áËÆ∞Âú∞Èõ∑
                </div>
            </div>
        `;
        
        const window = this.createWindow('Êâ´Èõ∑', content, 300, 350, 'üí£');
        this.setupMinesweeper(window);
    }

    setupMinesweeper(window) {
        const grid = window.querySelector('#minesweeper-grid');
        const rows = 9;
        const cols = 9;
        const mineCount = 10;
        
        let board = [];
        let gameStarted = false;
        let gameOver = false;
        
        // ÂàùÂßãÂåñÊ∏∏ÊàèÊùø
        const initBoard = () => {
            board = Array(rows).fill(null).map(() => Array(cols).fill({
                isMine: false,
                isRevealed: false,
                isFlagged: false,
                adjacentMines: 0
            }));
            
            // ÊîæÁΩÆÂú∞Èõ∑
            let minesPlaced = 0;
            while (minesPlaced < mineCount) {
                const row = Math.floor(Math.random() * rows);
                const col = Math.floor(Math.random() * cols);
                
                if (!board[row][col].isMine) {
                    board[row][col] = { ...board[row][col], isMine: true };
                    minesPlaced++;
                }
            }
            
            // ËÆ°ÁÆóÁõ∏ÈÇªÂú∞Èõ∑Êï∞
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    if (!board[row][col].isMine) {
                        let count = 0;
                        for (let r = -1; r <= 1; r++) {
                            for (let c = -1; c <= 1; c++) {
                                const newRow = row + r;
                                const newCol = col + c;
                                if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {
                                    if (board[newRow][newCol].isMine) count++;
                                }
                            }
                        }
                        board[row][col] = { ...board[row][col], adjacentMines: count };
                    }
                }
            }
        };
        
        // Ê∏≤ÊüìÊ∏∏ÊàèÊùø
        const renderBoard = () => {
            grid.innerHTML = '';
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const cell = document.createElement('div');
                    cell.style.width = '20px';
                    cell.style.height = '20px';
                    cell.style.border = '1px outset var(--win95-button-face)';
                    cell.style.background = 'var(--win95-button-face)';
                    cell.style.display = 'flex';
                    cell.style.alignItems = 'center';
                    cell.style.justifyContent = 'center';
                    cell.style.fontSize = '10px';
                    cell.style.cursor = 'pointer';
                    
                    const cellData = board[row][col];
                    
                    if (cellData.isRevealed) {
                        cell.style.border = '1px inset var(--win95-button-face)';
                        cell.style.background = 'var(--win95-white)';
                        
                        if (cellData.isMine) {
                            cell.textContent = 'üí£';
                            cell.style.background = 'red';
                        } else if (cellData.adjacentMines > 0) {
                            cell.textContent = cellData.adjacentMines;
                            const colors = ['', 'blue', 'green', 'red', 'purple', 'maroon', 'turquoise', 'black', 'gray'];
                            cell.style.color = colors[cellData.adjacentMines];
                        }
                    } else if (cellData.isFlagged) {
                        cell.textContent = 'üö©';
                    }
                    
                    // ‰∫ã‰ª∂ÁõëÂê¨
                    cell.addEventListener('click', () => revealCell(row, col));
                    cell.addEventListener('contextmenu', (e) => {
                        e.preventDefault();
                        toggleFlag(row, col);
                    });
                    
                    grid.appendChild(cell);
                }
            }
        };
        
        // ÁøªÂºÄÊñπÂùó
        const revealCell = (row, col) => {
            if (gameOver || board[row][col].isRevealed || board[row][col].isFlagged) return;
            
            board[row][col] = { ...board[row][col], isRevealed: true };
            
            if (board[row][col].isMine) {
                gameOver = true;
                // ÊòæÁ§∫ÊâÄÊúâÂú∞Èõ∑
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        if (board[r][c].isMine) {
                            board[r][c] = { ...board[r][c], isRevealed: true };
                        }
                    }
                }
                this.playErrorSound();
            } else if (board[row][col].adjacentMines === 0) {
                // Ëá™Âä®ÁøªÂºÄÁõ∏ÈÇªÁöÑÁ©∫ÊñπÂùó
                for (let r = -1; r <= 1; r++) {
                    for (let c = -1; c <= 1; c++) {
                        const newRow = row + r;
                        const newCol = col + c;
                        if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {
                            revealCell(newRow, newCol);
                        }
                    }
                }
            }
            
            renderBoard();
        };
        
        // ÂàáÊç¢Ê†áËÆ∞
        const toggleFlag = (row, col) => {
            if (gameOver || board[row][col].isRevealed) return;
            
            board[row][col] = { ...board[row][col], isFlagged: !board[row][col].isFlagged };
            renderBoard();
        };
        
        // ÂàùÂßãÂåñÊ∏∏Êàè
        initBoard();
        renderBoard();
    }

    // ÂØπËØùÊ°Ü
    showNotImplementedDialog(feature) {
        const content = `
            <div style="text-align: center; padding: 20px;">
                <div style="font-size: 32px; margin-bottom: 16px;">‚ö†Ô∏è</div>
                <div style="margin-bottom: 16px;">
                    "${feature}" ÂäüËÉΩÊöÇÊú™ÂÆûÁé∞
                </div>
                <div style="margin-bottom: 20px; font-size: 11px; color: var(--win95-dark-gray);">
                    ËØ•ÂäüËÉΩÂ∞ÜÂú®Êú™Êù•ÁöÑÁâàÊú¨‰∏≠Ê∑ªÂä†„ÄÇ
                </div>
                <button class="calculator-button" onclick="this.closest('.window').querySelector('[data-action=close]').click()">
                    Á°ÆÂÆö
                </button>
            </div>
        `;
        
        this.createWindow('ÊèêÁ§∫', content, 280, 180, '‚ö†Ô∏è');
    }

    showShutdownDialog() {
        const content = `
            <div style="padding: 20px; text-align: center;">
                <div style="font-size: 32px; margin-bottom: 16px;">üîå</div>
                <div style="margin-bottom: 20px;">
                    ÊÇ®Á°ÆÂÆöË¶ÅÂÖ≥Èó≠ËÆ°ÁÆóÊú∫ÂêóÔºü
                </div>
                <div style="display: flex; gap: 8px; justify-content: center;">
                    <button class="calculator-button" onclick="window.close()">
                        ÊòØ
                    </button>
                    <button class="calculator-button" onclick="this.closest('.window').querySelector('[data-action=close]').click()">
                        Âê¶
                    </button>
                </div>
            </div>
        `;
        
        this.createWindow('ÂÖ≥Èó≠ Windows', content, 300, 160, 'üîå');
    }
}

// ÂêØÂä®Ê°åÈù¢
document.addEventListener('DOMContentLoaded', () => {
    window.desktop = new Windows95Desktop();
});

// Èò≤Ê≠¢ÊãñÊîæÈªòËÆ§Ë°å‰∏∫
document.addEventListener('dragover', (e) => e.preventDefault());
document.addEventListener('drop', (e) => e.preventDefault());